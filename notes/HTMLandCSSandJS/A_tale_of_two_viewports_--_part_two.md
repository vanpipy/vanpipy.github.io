# 视窗的故事(二)

原文地址: [A tale of two viewports — part two](https://www.quirksmode.org/mobile/viewports2.html)
---

> 在该迷你系列中我将阐释的内容分为视窗和多个重要元素标签是如何运作, 比如`<html>`元素, 同样还有`window`和`screen`.

这个篇章呢，我们就开始聊聊移动设备中的浏览器。当然，如果你对于移动设备一筹莫展，那么我强烈建议首先阅读关于桌面浏览器的第一部分，以便于营造一种类似的学习环境。

# 问题? 移动设备中的浏览器
当我们将移动设备和桌面环境中的浏览器进行对比时，最明显的不同就是屏幕尺寸。移动设备中的浏览器展示一个经过桌面特性优化网站时，相比于桌面环境下的浏览器，那些优化点显著的减少；不论文字缩小到不可阅读的程度，还是只显示很小的一部分在屏幕中。

一个手机屏幕的尺寸远远小于桌面显示器；想想一下最宽只有400像素，甚至更窄。(有些手机供应商说他们的设备有更宽的尺寸，可惜他们都在撒谎 - 或者只给出一些无用的信息来混肴视听。)

平板设备的中间一部分，比如IPad或者可能存在基于HP的webOS系统开发的设备，都旨在弥合桌面设备和移动设备之间的空间，但是这种方式并没有改变根本的问题。网站一定，而且必然需要在移动设备中展示，所以我们得让网站在更小尺寸的屏幕中表现的一如既往的好才行。

最重要的问题集中在CSS中，特别是视窗的尺寸。假如我们完全按照桌面环境的样式模式，那样式将开始超出想象甚至很尴尬。

现在让我们回到宽度为10%的侧边栏。假如在移动设备的浏览器中也设置同样的属性，使这个元素的宽度最多为40像素，然后，那样就十分糟糕了。你可爱的流体布局可能看起来被挤压到了一堆。

其中一个解决方式是为移动设备专门构建一个特殊的网站。不过，除了你是否应该这样做的基本问题，实际的问题是只有很少的站点拥有者对移动设备做了足够的适配。

手机浏览器供应商想为他们的客户提供尽可能好的体验，就是现在通俗意义上描述“尽可能的像桌面环境”一样。于是一些奇诡的手段就成为了必要的了。

# 两个视窗
所以这个视窗作为你的样式布局的基础就特别糟糕。最明显的解决办法就是让视窗变的更宽。如此这么做，怎么说呢，需要划分成两类：虚拟视窗和布局视窗。

George Commins 对这类基础内容做出了[最棒的解释](https://stackoverflow.com/questions/6333927/difference-between-visual-viewport-and-layout-viewport)在 Stack Overflow：

> 想象一下，把布局视窗当成一个很大的图片，一个不会改变尺寸和形状的图片。现在想象你有一个更小一点的框框，可以通过它去观察那个很大的图片。这个稍小的框框被一圈不透明材质包围，这圈不透明的材质会模糊并阻止你看到很大图片的整个部分除了没有覆盖的地方。现在在很大的图片中你可以透过框框看到的那一部分，就是虚拟视窗。当你的框框稳定在一个位置的时候(缩小)，你可以尝试离很大图片远一点，去快速的看到整个图片，或者可以尝试走得更近一点(放大)，然后看到仅仅很小一部分。你同样也可以改变框框的方向，可是那个很大的图片(布局视窗)的尺寸和形状并不会改变。

也可以看一下 Chris 的[解释](https://stackoverflow.com/questions/7344886/visual-viewport-vs-layout-viewport-on-mobile-devices)。

虚拟视窗就是在当前页面显示在屏幕中的那一部分。用户可以通过滚动去改变他看到的内容，或者通过缩放去改变虚拟视窗的尺寸。

![](https://www.quirksmode.org/mobile/pix/viewport/mobile_visualviewport.jpg)

无论如何，样式布局，特别是那些百分比的宽度，都是相对于布局视窗来计算的，更多的情况下布局视窗总是比虚拟视窗更宽。

因此 `<html>` 元素一开始使用布局视窗的宽度，你的样式就是如此解读的，就好像屏幕看起来很明显的比手机屏幕宽很多。这样就确保你的网站的布局行为表现的样子就如同桌面浏览器一样。

布局视窗的宽度是多少? 这个数据可能每个浏览器都不一样。Safari IPhone 使用980像素，Opera是850像素，Android WebKit是800像素，然后IE是974像素。

同时有些浏览器还有一些奇特的操作：

+ Symbian WebKit 会尝试保持布局视窗全等于虚拟视窗，是的，这样就意味着百分比宽度的元素会表现的很奇怪。不过怎么说呢，要是整个页面不适应绝对宽度的虚拟视窗的话，浏览器就会把布局视窗拉伸到850像素的最大宽度。

+ Samsung WebKit (bada) 的布局视窗会保持同最宽的那个元素一样的宽度。

+ 在 BlackBerry 中，布局视窗，在100%的缩放比例下，等于虚拟视窗。这好像没啥变化。

# 缩放
显然，所有的视窗衡量的单位都是样式像素。但是当虚拟视窗通过缩放改变的时候(如果你放大，CSS像素将会更少的出现在屏幕中)，而布局视窗的尺寸仍然一样。(要是他们不这样，你的页面会不断按照重新计算的百分比宽度进行重排。)

# 理解布局视窗
为了理解布局视窗的尺寸是什么，我们得先看看当缩小到最小程度时候发生了什么。许多手机上的浏览器一开始都最大程度的缩小模式不管展示什么内容。

重点是：浏览器选择了他们的布局视窗的尺寸，这样就完全的覆盖了整个屏幕在最大程度的缩小模式下(这个时候就等于虚拟视窗)

![](https://www.quirksmode.org/mobile/pix/viewport/mobile_viewportzoomedout.jpg)

因此布局视窗的宽和高就等于在最大程度的缩小模式下的任何展示在屏幕里的内容。即便是用户放大这些尺寸也保持一样。

![](https://www.quirksmode.org/mobile/pix/viewport/mobile_layoutviewport.jpg)

布局视窗的宽度总是一样的。如果你旋转你的手机，虚拟视窗发生了改变，但是浏览器会稍微的放大一下去适应新的方向，于是布局视窗又再次保持和虚拟视窗一样的宽度了。

![](https://www.quirksmode.org/mobile/pix/viewport/mobile_viewportzoomedout_la.jpg)

这样会影响布局视窗的高度，视窗的高度远远小于纵向模式的高度。但是Web开发者根本不关心这个高度，只关心宽度。

![](https://www.quirksmode.org/mobile/pix/viewport/mobile_layoutviewport_la.jpg)

# 如何测量布局视窗的尺寸
现在有两种视窗的尺寸需要我们去测量。然后非常幸运的是，浏览器大战给予了我们两对这样的属性。

`document.documentElement.clientWidth`和`-Height`包含了布局视窗的尺寸。

![](https://www.quirksmode.org/mobile/pix/viewport/mobile_client.jpg)

屏幕方向和高度紧密相关，跟宽度没什么联系。

![](https://www.quirksmode.org/mobile/pix/viewport/mobile_client_la.jpg)

# 如何测量虚拟视窗的尺寸
对于虚拟视窗而言，可以使用 `window.innerWidth/Height`来获取相应的尺寸。显然的，当用户尝试进行缩放操作的时候，这个测量结果是会变化的，因为可能有更多或者更少的CSS像素点填充在屏幕中。

![](https://www.quirksmode.org/mobile/pix/viewport/mobile_inner.jpg)

可惜的是，这里是一个尚未获得兼容的区域；许多浏览器依然保持了对虚拟视窗测量功能的支持，同时还有一些浏览器没有这样的测量功能支持，所以我估计 `window.innerWidth/Height` 算是一个标准，尽管是一个比较糟糕的支持属性。

# 屏幕
在桌面设备中，`screen.width/height` 给出了屏幕的尺寸，基于设备像素的基本单位。当然在桌面环境中，作为一个开发者你根本不需要这样的信息。你对屏幕的物理尺寸也根本不感兴趣，除了有多少CSS像素填充在屏幕中。

![](https://www.quirksmode.org/mobile/pix/viewport/mobile_screen.jpg)

# 缩放比例
直接得到缩放比例的数据是不存在的，但是你可以通过 `screen.width` 和 `window.innerWidtth` 的整除计算结果来得到。当然这种方式只在用到的属性都被良好支持的情况下才可以。

不过幸运的是缩放比例并没什么卵用也不重要。你需要关心的是当前有多少CSS像素点填充在屏幕中。你可以用 `window.innerWdith` 来获得这些数据 - 当然属性被正确支持的情况下。

# 滚动偏移量
还有一些你需要知道的是当前虚拟视窗相对于布局视窗，其所在的位置。这就是滚动偏移量，就和桌面环境中一样，存储在 `window.pageX/YOffset` 属性。

![](https://www.quirksmode.org/mobile/pix/viewport/mobile_page.jpg)

# `html` 元素
和桌面环境一样， `document.documentElement.offsetWidth/Height` 给出了 `<html>` 元素CSS像素级别的完整尺寸。

![](https://www.quirksmode.org/mobile/pix/viewport/mobile_offset.jpg)

# 媒体查询类
媒体查询作用的方式也同桌面环境下一样。宽度和高度都使用布局视窗作为参考系也基于CSS像素来进行测量，设备宽度和高度基于设备像素级别来进行测量。

换个说法的话，宽度和高度反映为 `document.documentElement.clientWidth/Height`，同时设备宽度和高度也反应为 `screen.width/height`。(在所有的浏览器这个说法都成立，即便反映的数值有误。)

![](https://www.quirksmode.org/mobile/pix/viewport/mobile_mediaqueries.jpg)

现在让我们看看哪些测量结果对web开发者来说是更有用的呢? 重点是，其实我也不知道。

我曾经考虑设备宽度应该是最重要的一个，因为它让我们了解我们能够使用的设备的一些信息。举个例子，你可以改变你的布局宽度去容纳设备的宽度。不管怎么说，你还可以通通过 `<meta viewport>` 的方式去做同样的事情；并没有绝对的必要去使用设备媒体查询。

所以是不是宽度是更重要的媒体查询方式? 嗯...可能吧；它让我们看到一些想法的痕迹，在设备上浏览器供应商设想的一种拥有良好宽度表现的网站。但是那样实在是让人感到茫然，实际上宽度的媒体查询并没有给出任何其他信息。

所以我也是无法决定。有时候我会思考媒体查询对于区分你是在桌面，或者平板，或者是手机设备来说很重要，但是对于分辨众多的平板和手机设备来说，又没那么有用。

或许还有其他可能。

# 事件坐标
事件坐标工作的方式也同桌面环境一样。不过不走运的是，在十二种经过测试的浏览器里面，只有两种，Sybian Webkit 和 Iris，获取三个属性对的结果是完全正确的。其他的浏览器或多或少都有一些严重的问题。

`pageX/Y` 依然基于CSS像素级别相对于页面进行定位，这也是目前为止三个属性对里面最有用的一个，就同桌面环境一样。

![](https://www.quirksmode.org/mobile/pix/viewport/mobile_pageXY.jpg)

`clientX/Y` 是基于CSS像素级别相对于虚拟视窗进行定位。这个好像蛮有意义的，虽然我也不能完全确定有什么好处。

`screenX/Y` 是基于设备像素级别相对于屏幕进行定位。当然，使用的参考系同 `clientX/Y` 是一样的，设备像素没什么用。所以我们完全不用担心 `screenX/Y`；就和桌面环境里面一样，没有什么用。

![](https://www.quirksmode.org/mobile/pix/viewport/mobile_clientXY.jpg)

# 元视窗
最后，让我们来讨论一下 `<meta name="viewport" content="width=320">`；最初是是一个Apple扩展名但是随后被更多的浏览器复制引用。它意味者调整布局视窗。为了明白为什么这个很有必要，我们先回到上一步。

假如你构建一个简单的页面，同时对任何元素都不赋予宽度。现在他们保持伸展将布局视窗的百分百宽度作为自己的宽度。大部分浏览器会缩小整个布局视窗展现在屏幕上，会表现的如下：

![](https://www.quirksmode.org/mobile/pix/viewport/mq_none.jpg)

所有的用户立马就会去放大，这是有效的，但是大部分浏览器会完整的保持元素的宽度，这使文本阅读变得困难。

![](https://www.quirksmode.org/mobile/pix/viewport/mq_none_zoomed.jpg)

(有个特别的例外是Android WebKit，它竟然减少了文本容器元素的尺寸以便于文本去适应填充在屏幕里。这绝对是不能再机智了，而且我认为所有的浏览器都应该复制引用这种行为。稍后我会完整的描述该现象。)

现在你可以能够尝试的是去设置 html {width: 320px}。现在 `<html>` 收缩了，同时也包含所有其他的元素，都把320像素作为百分百的宽度。当用户放大时也时这样的，但是一开始并不是这样的，当用户面对的是缩小的页面时，可能里面什么都没有。

![](https://www.quirksmode.org/mobile/pix/viewport/mq_html300.jpg)

这是为了追溯和解释为什么Apple要发明 meta viewport 整个标签。当你设置 `<meta name="viewport" content="width=320">` 的时候，你就设置布局视窗的宽度为320像素。好了，现在页面的初始状态也正确了。

![](https://www.quirksmode.org/mobile/pix/viewport/mq_yes.jpg)

你可以把布局视窗的宽度设置成任意你想要的尺寸，包括设备尺寸。最后一个会获取屏幕的宽度(设备像素级别)作为参考系，布局视窗会依照整个参考系进行调整。

但是，这里有一个问题。有时候通常情况下屏幕的宽度并没有什么意义因为像素计数太高了。举个栗子，Nexus One 正式宽度为480像素，但是谷歌的工程师觉得480像素宽度的布局视窗在使用设备时实在太多了。于是他们削减到三分之二，所以实际上设备宽度时320像素，就和IPhone一样。

假设，如果新的IPhone宣称他们将有更大的像素(这并不一定等于更大的屏幕！)，我并不会惊讶Apple复制了这种行为。可能最后设备的宽度依然是320像素。

# 相关研究
几个之后会进行研究的相关话题：

* position: fixed. 如我们所知，一个固定的元素，相对于视窗进行定位。但是相对于哪一个视窗? 同时在做[这个研究](https://www.quirksmode.org/blog/archives/2010/12/the_fifth_posit.html)

* Other media queries: dpi, orientation, aspect-ratio. DPI(Dots Per Inch，每英寸点数)是个祸害区域，不仅因为所有浏览器报告96dpi，这个通常都是假的，而且因为我也不能十分确定对于web开发者那些数值他们更感兴趣。

* 当一个元素的宽度比布局视窗或者HTML元素更宽的时候发生了什么? 比如我把一个1500像素宽度的元素放到我的测试页面? 这个元素将会伸到HTML元素外面去([overflow](https://www.quirksmode.org/css/overflow.html): visible)，但是这以为着实际的视窗会变得比布局视窗更宽。另一种情况，老版本的Android(Nexus One)会扩大HTML元素。这会不会是一个好主义?
